`timescale 1ns/1ps

module tb_parta;

  localparam int DATA_WIDTH = 8;
  localparam int DEPTH      = 8;
  localparam int N          = 8;

  // -----------------------------
  // clock / reset / start
  // -----------------------------
  logic clk;
  logic rst_n;
  logic start;

  // -----------------------------
  // Avalon-MM wires (controller <-> mem_wrapper)
  // -----------------------------
  logic [31:0] avm_address;
  logic        avm_read;
  logic [63:0] avm_readdata;
  logic        avm_readdatavalid;
  logic        avm_waitrequest;

  // -----------------------------
  // FIFO bank signals
  // -----------------------------
  logic [7:0] a_full, a_empty;
  logic [7:0] a_wren;
  logic [DATA_WIDTH-1:0] a_wdata [0:7];
  logic [7:0] a_rden;
  logic [DATA_WIDTH-1:0] a_rdata [0:7];

  logic       b_full, b_empty;
  logic       b_wren;
  logic [DATA_WIDTH-1:0] b_wdata;
  logic       b_rden;
  logic [DATA_WIDTH-1:0] b_rdata;

  // -----------------------------
  // controller status/debug
  // -----------------------------
  logic       load_done;
  logic [3:0] dbg_state, dbg_addr;
  logic [2:0] dbg_row, dbg_byte;

  // -----------------------------
  // MAC8 interface
  // -----------------------------
  logic En_in, Clr_in;

  // IMPORTANT: we drive MAC8's b_in explicitly (not directly from FIFO),
  // so we can feed b[0..7] then zeros for pipeline tail cycles.
  logic [DATA_WIDTH-1:0] b_mac;

  logic [DATA_WIDTH-1:0] a_in [0:7];
  logic [DATA_WIDTH*3-1:0] c_out [0:7];

  // optional exports from MAC8 (handy to debug alignment)
  logic [N-1:0] en_out, clr_out;
  logic [DATA_WIDTH-1:0] b_out [0:N-1];

  // =====================================================
  // Clock generation: 50 MHz -> 20 ns period
  // =====================================================
  initial clk = 1'b0;
  always #10 clk = ~clk;

  // =====================================================
  // DUT: mem_wrapper (slave)
  // =====================================================
  mem_wrapper u_mem (
    .clk          (clk),
    .reset_n      (rst_n),
    .address      (avm_address),
    .read         (avm_read),
    .readdata     (avm_readdata),
    .readdatavalid(avm_readdatavalid),
    .waitrequest  (avm_waitrequest)
  );

  // =====================================================
  // DUT: controller (master, fills FIFOs)
  // =====================================================
  controller u_ctrl (
    .clk              (clk),
    .rst_n            (rst_n),
    .start            (start),
    .done             (load_done),

    .avm_address      (avm_address),
    .avm_read         (avm_read),
    .avm_readdata     (avm_readdata),
    .avm_readdatavalid(avm_readdatavalid),
    .avm_waitrequest  (avm_waitrequest),

    .a_fifo_wren      (a_wren),
    .a_fifo_wdata     (a_wdata),

    .b_fifo_wren      (b_wren),
    .b_fifo_wdata     (b_wdata),

    .dbg_state        (dbg_state),
    .dbg_addr         (dbg_addr),
    .dbg_row          (dbg_row),
    .dbg_byte         (dbg_byte)
  );

  // =====================================================
  // 8x A FIFOs
  // =====================================================
  genvar r;
  generate
    for (r = 0; r < 8; r = r + 1) begin : A_FIFOS
      FIFO #(
        .DEPTH(DEPTH),
        .DATA_WIDTH(DATA_WIDTH)
      ) u_fifo_a (
        .clk   (clk),
        .rst_n (rst_n),
        .rden  (a_rden[r]),
        .wren  (a_wren[r]),
        .i_data(a_wdata[r]),
        .o_data(a_rdata[r]),
        .full  (a_full[r]),
        .empty (a_empty[r])
      );
    end
  endgenerate

  // =====================================================
  // 1x B FIFO
  // =====================================================
  FIFO #(
    .DEPTH(DEPTH),
    .DATA_WIDTH(DATA_WIDTH)
  ) u_fifo_b (
    .clk   (clk),
    .rst_n (rst_n),
    .rden  (b_rden),
    .wren  (b_wren),
    .i_data(b_wdata),
    .o_data(b_rdata),
    .full  (b_full),
    .empty (b_empty)
  );

  // =====================================================
  // MAC8 wiring (a_in <= a_rdata)
  // =====================================================
  always_comb begin
    for (int i = 0; i < 8; i++) begin
      a_in[i] = a_rdata[i];
    end
  end

  MAC8 #(
    .DATA_WIDTH(DATA_WIDTH),
    .N(N)
  ) u_mac8 (
    .clk    (clk),
    .rst_n  (rst_n),
    .En_in  (En_in),
    .Clr_in (Clr_in),
    .b_in   (b_mac),
    .a_in   (a_in),
    .c_out  (c_out),
    .en_out (en_out),
    .clr_out(clr_out),
    .b_out  (b_out)
  );

  // =====================================================
  // Print (optional)
  // =====================================================
  task automatic print_status;
    $display("[%0t] a_in=%p b_mac=%02h b_out=%p En=%0b Clr=%0b Arden=%b Brden=%0b c_out=%p",
      $time, a_in, b_mac, b_out, En_in, Clr_in, a_rden, b_rden, c_out);
  endtask

  // comment this out if too chatty
  always_ff @(posedge clk) if (rst_n) print_status();

  // =====================================================
  // Timeout helper
  // =====================================================
  task automatic wait_load_done_or_timeout;
    fork
      begin
        wait (load_done == 1'b1);
      end
      begin
        repeat (5000) @(posedge clk);
        $fatal(1, "TIMEOUT: controller never asserted load_done");
      end
    join_any
    disable fork;
  endtask

  // =====================================================
  // One systolic step (k = 0..14)
  // =====================================================
  task automatic systolic_step(input int k);
    // Feed B for first 8 cycles (b[0..7]), then zeros for the 7 tail cycles.
    // NOTE: FIFO o_data updates on posedge when rden is asserted.
    b_rden = (k < N);
    b_mac  = (k < N) ? b_rdata : '0;

    // Stagger A reads so lane i starts at cycle i.
    // We only need N elements per lane total; because FIFO output updates on posedge,
    // we read "next element" for the next cycle.
    for (int i = 0; i < N; i++) begin
      // Read for k in [i .. i+6] to fetch next A element (7 pops after preload gives 8 total)
      a_rden[i] = (k >= i) && (k < (i + (N-1)));
    end

    En_in  = 1'b1;
    Clr_in = 1'b0;

    @(posedge clk);
  endtask

  // =====================================================
  // Test sequence
  // =====================================================
  initial begin
    // init
    rst_n = 1'b0;
    start = 1'b0;

    a_rden = 8'h00;
    b_rden = 1'b0;

    En_in  = 1'b0;
    Clr_in = 1'b0;
    b_mac  = '0;

    // reset for a few cycles
    repeat (4) @(posedge clk);
    rst_n = 1'b1;
    @(posedge clk);

    // start controller
    start = 1'b1;

    $display("---- Waiting for controller to fill FIFOs ----");
    wait_load_done_or_timeout();
    $display("---- Controller done: FIFOs filled ----");

    // -------------------------------------------------
    // PRELOAD:
    // Pop first element of each A FIFO and first element of B FIFO into o_data regs.
    // En=0 so MACs do not accumulate while we clear.
    // -------------------------------------------------
    $display("---- EXEC: preload (En=0, Clr=1) ----");
    Clr_in = 1'b1;
    En_in  = 1'b0;

    a_rden = 8'hFF;
    b_rden = 1'b1;
    b_mac  = b_rdata;   // b_rdata becomes b[0] after this edge
    @(posedge clk);

    // release clear
    Clr_in = 1'b0;

    // -------------------------------------------------
    // SYSTOLIC RUN:
    // Need (N + N - 1) = 15 cycles so lane 7 gets all 8 multiplies.
    // -------------------------------------------------
    $display("---- EXEC: systolic run (15 cycles) ----");
    for (int k = 0; k < (N + N - 1); k++) begin
      systolic_step(k);
    end

    // stop
    a_rden = 8'h00;
    b_rden = 1'b0;
    En_in  = 1'b0;
    b_mac  = '0;

    repeat (3) @(posedge clk);

    // Print final results
    $display("---- FINAL c_out results ----");
    for (int i = 0; i < 8; i++) begin
      $display("c_out[%0d] = 0x%0h", i, c_out[i]);
    end

    $display("---- TEST DONE ----");
    $stop();
  end

endmodule

